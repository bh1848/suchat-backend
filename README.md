[!suchat_overview](./docs/images/suchat_overview.png)


# Suchat
수원대학교 랜덤 채팅 어플리케이션입니다.

## 1. 프로젝트 소개
Suchat은 수원대학교 학생들을 위한 랜덤 채팅 서비스입니다.  
회원 인증, 이메일 인증, 랜덤 매칭, 실시간 채팅 기능을 포함한 백엔드 시스템으로,  
Spring Boot와 JWT 기반 인증 구조를 적용해 안전한 채팅 환경을 목표로 개발했습니다.

<br>

## 2. 시스템 구조

<br>

## 3. 기술 스택

### Backend
- Java 11 · Spring Boot · Spring Security + JWT  
- JPA · MySQL · Redis  
- Gradle

### Frontend
- Flutter (Mobile)

### Infrastructure
- AWS EC2

<br>

## 4. 핵심 기능

### 사용자(User)
- 회원가입 / 로그인 / 회원 정보 조회  
- 이메일 인증(회원가입 시 토큰 발급 및 검증)  
- 실시간 랜덤 매칭  
- 실시간 채팅

<br>

## 5. 담당 업무(Backend)
본 프로젝트에서 백엔드 기능, 보안, 데이터베이스, 인프라 전반을 담했습니다.  

### 인증·보안
- Spring Security + JWT 기반 인증·인가 구조 설계  
- Access / Refresh Token 설계 및 적용  
- 이메일 인증 토큰 발급 및 검증 로직 구현  
- 만료된 인증 토큰 삭제 스케줄러 작성  

### 회원 관리
- 회원가입 / 로그인 API 및 서비스 로직 개발  

### 매칭
- Redis Sorted Set(ZSET)을 활용한 랜덤 매칭 큐 구현  
- 2명 이상 대기 시 자동으로 매칭 → roomId 생성  

<br>

## 6. 트러블 슈팅

### 1. Redis ZSet 및 비동기 기반 논블로킹 매칭 엔진 설계
[👉 포스트 보러가기](https://hzeror.netlify.app/suchat-redis-zset-async/)

- **Situation:**
  - 다중 서버 환경에서 유저 간 매칭 상태 공유가 필요했으며, 일반적인 자료구조 사용 시 매칭 취소 요청 처리에 따른 성능 병목이 우려됨.
  - 매칭 연산을 동기적으로 처리할 경우 트래픽 밀집 시 클라이언트 응답 대기 시간(Latency)이 길어지는 문제가 예상됨.
- **Task:** 서버 인스턴스에 종속되지 않으면서 탐색 및 삭제 연산이 최적화된 분산 큐를 설계하고, 응답성을 극대화할 수 있는 비동기 구조를 구축해야 함.
- **Action:**
  - 타임스탬프를 Score로 사용하는 Redis `ZSet`을 도입하여 FIFO 정렬을 보장하고, 매칭 취소 시 탐색 복잡도를 $\mathcal{O}(\log N)$으로 최적화함.
  - `@Async`와 `CompletableFuture`를 활용하여 매칭 알고리즘을 별도의 스레드 풀로 격리(Isolation) 처리하는 비동기 논블로킹 아키텍처를 설계함.
- **Result:**
  - 큐 진입 요청에 대한 응답 속도를 비약적으로 향상함과 동시에, 분산 환경에서 탐색 및 취소 병목이 없는 안정적인 매칭 파이프라인을 확보함.
  - 동기식 처리 대비 워커 스레드의 점유 시간을 단축하여 시스템 전체의 처리량(Throughput)을 개선함.


### 2. 하이브리드 토큰 보안 아키텍처: Redis RTR 도입
[👉 포스트 보러가기](https://hzeror.netlify.app/suchat-jwt-redis-rtr/)

- **Situation:** Stateless 기반 JWT 도입 시, 토큰이 탈취되더라도 서버 측에서 이를 강제로 무효화할 수 없는 구조적 보안 취약점이 존재함.
- **Task:**
  - Access Token 탈취 리스크를 최소화하고, 서버가 클라이언트 세션에 직접 개입할 수 있는 통제권을 확보해야 함.
- **Action:**
  - Access Token의 수명을 30분으로 단축하고, 2주 수명의 Refresh Token을 Redis에 저장하는 하이브리드 구조를 설계함.
  - 토큰 재발급 시 기존 리프레시 토큰을 폐기하고 신규 토큰을 발급하는 RTR(Refresh Token Rotation) 로직을 구현하여 재사용 공격(Replay Attack)을 차단함.
  - 로그아웃 및 회원 탈퇴 시 Redis 내 토큰 데이터를 즉시 삭제하고, 토큰 검증 시 Redis 존재 여부(`hasKey`)를 대조하는 화이트리스트 방식을 적용함.
- **Result:**
  - Stateless 인증의 확장성을 유지하면서도 탈취된 토큰을 실시간으로 차단할 수 있는 서버 제어권을 확보함.
  - 전통적인 세션 방식 대비 성능 저하를 최소화($\mathcal{O}(1)$ 연산)하면서 강력한 보안 인증망을 구축함.
 
### 3. @Scheduled 기반 자동 클리닝으로 Ghost Data 제거
[👉 포스트 보러가기](https://hzeror.netlify.app/shchat-ghost-data-scheduled/)

- **Situation:**
  - 수챗(Suchat) 프로젝트의 회원가입은 이메일 인증을 완료해야 정식 회원으로 인정되는 2단계 구조를 가짐.
  - 인증 전 데이터는 임시 테이블(`MemberTemp`)에 보관되나, 가입 도중 이탈한 유저의 데이터가 DB에 유령 데이터(Ghost Data)로 무한정 적재되는 문제가 발생함.
- **Task:**
  - 시스템 생명주기 통제에서 벗어난 고아 데이터(Orphan Data)를 정리하여 스토리지 낭비를 방지해야 함.
  - 동일한 식별자로 재가입 시 발생하는 PK/UK 충돌 이슈를 해결하여 사용자 경험(UX)을 개선해야 함.
- **Action:**
  - Spring의 `@Scheduled` 어노테이션을 활용하여 1분 주기(`0 * * * * *`)로 동작하는 백그라운드 클리닝 파이프라인을 설계함.
  - 토큰 만료 시간인 5분에 30분의 유예 기간을 추가로 부여하여 네트워크 지연 등 예외 상황을 고려한 삭제 로직을 구현함.
  - `@Transactional`을 선언하여 데이터 삭제 과정의 원자성을 확보하고 데이터 무결성을 유지함.
- **Result:**
  - 불필요한 유령 데이터 적재를 방지하여 데이터베이스 공간 효율성을 상시 최적화함.
  - 가입 이탈 사용자의 재가입 불가 문제를 선제적으로 해결하여 시스템 안정성과 UX를 동시에 확보함.

<br>

## 7. 회고록
이 프로젝트는 독학으로 JWT, Redis 구조를 직접 학습하며 진행한  
첫 실시간 서비스 백엔드 프로젝트였습니다.

자료나 참고 예제가 많지 않아 많은 시행착오가 있었지만,  
필요한 기능을 하나씩 구현해 나가면서 백엔드 전반과 실시간 시스템 구조에 대한 이해도를 크게 높일 수 있었습니다.

학업과 병행한 첫 대형 프로젝트였기에 실제 서비스까지는 이어지지 않았지만,  
이 과정에서 경험한 한계와 부족한 점들은 이후 프로젝트들을 설계할 때  
더 안정적인 구조를 고민하는 기준점이 되었습니다.
